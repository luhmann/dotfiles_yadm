# quick navigation
alias ddev='cd ~/Dev'
alias ddot='cd ~/Dev/dotfiles'
alias dh='cd ~'

alias ..='cd ..'
alias ...='cd ../..'
alias ....='cd ../../..'

# utils
alias fname='find . -iname'
alias genkey='openssl req -newkey rsa:2048 -new -nodes -x509 -days 3650 -subj "/C=US/ST=Denial/L=Springfield/O=Dis/CN=localhost" -keyout key.pem -out cert.pem'
alias ccat='pygmentize -g'
alias hosts='sudo vim /etc/hosts'
alias ip='dig +short myip.opendns.com @resolver1.opendns.com'
alias ips="ifconfig -a | perl -nle'/(\d+\.\d+\.\d+\.\d+)/ && print $1'"
alias o='open'
alias oo='open .'
alias pubkey="more ~/.ssh/id_ed25519.pub | pbcopy | echo '=> Public key copied to pasteboard.'"
alias v='vim'
alias sudo='sudo '
alias update='sudo softwareupdate -i -a; brew update; brew upgrade; brew cleanup; brew cu; zinit update;'
alias ifactive="ifconfig | pcregrep -M -o '^[^\t:]+:([^\n]|\n\t)*status: active'"
alias vimup='vim +PlugUpgrade +PlugUpdate +qa!'
alias exclude='vim .git/info/exclude'
alias sep="echo '------------------->'"
alias todo="ultralist"

# get some help on nearly anything
cheat() {
  curl cheat.sh/$1
}

weather() {
  curl -4 wttr.in/${1:-berlin}
}

# fe [FUZZY PATTERN] - Open the selected file with the default editor
#   - Bypass fuzzy finder if there's only one match (--select-1)
#   - Exit if there's no match (--exit-0)
fe() {
  local files
  IFS=$'\n' files=($(fzf-tmux --query="$1" --multi --select-1 --exit-0))
  [[ -n "$files" ]] && ${EDITOR:-vim} "${files[@]}"
}

# c - browse chrome history
c() {
  local cols sep google_history open
  cols=$(( COLUMNS / 3 ))
  sep='{::}'

  if [ "$(uname)" = "Darwin" ]; then
    google_history="$HOME/Library/Application Support/Google/Chrome/Default/History"
    open=open
  else
    google_history="$HOME/.config/google-chrome/Default/History"
    open=xdg-open
  fi
  cp -f "$google_history" /tmp/h
  sqlite3 -separator $sep /tmp/h \
    "select substr(title, 1, $cols), url
     from urls order by last_visit_time desc" |
  awk -F $sep '{printf "%-'$cols's  \x1b[36m%s\x1b[m\n", $1, $2}' |
  fzf --ansi --multi | sed 's#.*\(https*://\)#\1#' | xargs $open > /dev/null 2> /dev/null
}

## docker
# Select a docker container to start and attach to
function da() {
  local cid
  cid=$(docker ps -a | sed 1d | fzf -1 -q "$1" | awk '{print $1}')

  [ -n "$cid" ] && docker start "$cid" && docker attach "$cid"
}

# Select a running docker container to stop
function ds() {
  local cid
  cid=$(docker ps | sed 1d | fzf -q "$1" | awk '{print $1}')

  [ -n "$cid" ] && docker stop "$cid"
}

## brew helper
# Install (one or multiple) selected application(s)
# using "brew search" as source input
# mnemonic [B]rew [I]nstall [P]lugin
bip() {
  local inst=$(brew search | fzf -m)

  if [[ $inst ]]; then
    for prog in $(echo $inst);
    do; brew install $prog; done;
  fi
}

function load_asdf() {
  . $(brew --prefix asdf)/libexec/asdf.sh
}

# git shortcuts
alias g='git'
alias ga='git add --all .'
alias gc='git commit'
alias gco='git checkout'
alias gam='git commit --amend --no-edit'
alias gp='git remote prune origin'
alias gl="git log --graph --pretty=format:'%Cred%h%Creset %an: %s - %Creset %C(yellow)%d%Creset %Cgreen(%cr)%Creset' --abbrev-commit --date=relative"
alias gs='git status -sb'
alias gurl='git config --get remote.origin.url'
alias gclean='git branch | grep -v "master\|main" | xargs git branch -D'

## jump to project in travis
alias trav='git-trav'
## jump to repo
alias repo='gh repo view --web'
## work with issues
alias issues="gh issue list --web"
## work with prs
alias prs="gh pr list --web"
alias pr="gh pr create --web"
## me
alias me="open 'https://github.com/luhmann'"
alias repos="open 'https://github.com/luhmann?tab=repositories'"
alias stars="open 'https://github.com/luhmann?tab=stars'"

## Switch git branches with fzf
fbr() {
  local branches branch
  branches=$(git for-each-ref --count=30 --sort=-committerdate refs/heads/ --format="%(refname:short)") &&
  branch=$(echo "$branches" |
           fzf-tmux -d $(( 2 + $(wc -l <<< "$branches") )) +m) &&
  git checkout $(echo "$branch" | sed "s/.* //" | sed "s#remotes/[^/]*/##")
}

# fshow - git commit browser
fshow() {
  git log --graph --color=always \
      --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
  fzf --ansi --no-sort --reverse --tiebreak=index --bind=ctrl-s:toggle-sort \
      --bind "ctrl-m:execute:
                (grep -o '[a-f0-9]\{7\}' | head -1 |
                xargs -I % sh -c 'git show --color=always % | less -R') << 'FZF-EOF'
                {}
FZF-EOF"
}

function com () {
    git commit -m "$*"
}

function gitstash() {
    git stash push --include-untracked -m "zsh_stash_name_$1"
}

function gitstashapply() {
    git stash apply $(git stash list | grep "zsh_stash_name_$1" | cut -d: -f1)
}

# remap of native tools for better experience
alias cat='bat'
alias ll='eza -lag'
alias du='ncdu --color dark -rr -x --exclude .git --exclude node_modules'
# commented because it breaks other tools that use find
# alias find='fd'

# reload shell
alias reload='exec $SHELL -l'

# list all processes that currently connect to the internet
alias listpi='lsof -P -i -n'
alias listpo='lsof -Pni4 | grep LISTEN | column -t'

# view HTTP traffic
alias sniff="sudo ngrep -d 'en1' -t '^(GET|POST) ' 'tcp and port 80'"
alias httpdump="sudo tcpdump -i en1 -n -s 0 -w - | grep -a -o -E \"Host\: .*|GET \/.*\""

# hide/show all desktop icons (useful when presenting)
alias hidedesktop="defaults write com.apple.finder CreateDesktop -bool false && killall Finder"
alias showdesktop="defaults write com.apple.finder CreateDesktop -bool true && killall Finder"

# lock the screen (when going AFK)
alias afk="/System/Library/CoreServices/Menu\ Extras/User.menu/Contents/Resources/CGSession -suspend"

# delete entries containing string from history
histrm() {
  gsed -i "/$1/d" $HISTFILE
}

# encoding /decoding
alias urldecode='python -c "import sys, urllib as ul; \
    print ul.unquote_plus(sys.argv[1])"'
alias urlencode='python -c "import sys, urllib as ul; \
    print ul.quote_plus(sys.argv[1])"'

sha1 () {
  echo -n "$1" | shasum -a 1 | awk '{print $1}' | pbcopy
}

# fkill - kill processes - list only the ones you can kill. Modified the earlier script.
fkill() {
    local pid
    if [ "$UID" != "0" ]; then
        pid=$(ps -f -u $UID | sed 1d | fzf -m | awk '{print $2}')
    else
        pid=$(ps -ef | sed 1d | fzf -m | awk '{print $2}')
    fi

    if [ "x$pid" != "x" ]
    then
        echo $pid | xargs kill -${1:-9}
    fi
}

# dev
## yarn shortcuts
alias yt="yarn test"
alias ys="yarn start"

## kill node processes
alias kn="killall node"

## recursively delete all node_modules
alias nukenm="find . -name "node_modules" -exec rm -rf '{}' +"

## backup patch of current changes to cloud
function pcloud() {
    git diff > /Users/jfd/Library/Mobile\ Documents/com~apple~CloudDocs/patches/"$1".patch
}

## show request-headers
function rh() {
    curl -s -D - "$1" -o /dev/null
}

# Same as below but with less info
function perf {
  curl -o /dev/null -s -w "%{time_connect} + %{time_starttransfer} = %{time_total}\n" "$1"
}

function docker-run-interactive {
  docker run -it --entrypoint "" -e AWS_PROFILE=${AWS_PROFILE} -v $(pwd):/app -v ${HOME}/.aws:/root/.aws --platform=linux/amd64 "$1" sh -c "cd /app/; sh"
}

# Break down of timings for one request
function curl_time() {
    curl -w "\
   namelookup:  %{time_namelookup}s\n\
      connect:  %{time_connect}s\n\
   appconnect:  %{time_appconnect}s\n\
  pretransfer:  %{time_pretransfer}s\n\
     redirect:  %{time_redirect}s\n\
starttransfer:  %{time_starttransfer}s\n\
-------------------------\n\
        total:  %{time_total}s\n" "$@"
}

function node-project() {
  git init
  npx license $(npm get init.license) -o "$(npm get init.author.name)" > LICENSE
  npx gitignore node
  npx covgen "$(npm get init.author.email)"
  npm init -y
  git add -A
  git commit -m "Initial commit"
}


function build_dockerfile() {
  docker build . -t $1 -f ./Dockerfile
}

function run_dockerfile() {
  docker run -d $1
}

function img-data() {
  TYPE=$(file --mime-type -b $1)
  ENC=$(base64 $1)
  echo "data:$TYPE;base64,$ENC"
}

# time zsh startup time
timezsh() {
  shell=${1-$SHELL}
  for i in $(seq 1 10); do /usr/bin/time $shell -i -c exit; done
}

# count lines of code in a repo omitting some files
cloc() {
git ls-files --exclude-standard -- ':!:**/*.[pjs][npv]g' ':!:**/*.ai' ':!:.idea' ':!:**/*.eslintrc' ':!:package-lock.json' | xargs wc -l
}

cc() {
  code .
}

# ----------------------------------------------------
# gtw  – create + enter a git work-tree for <branch>
# ----------------------------------------------------
gtw () {
  local branch=$1
  [[ -z $branch ]] && { echo "Usage: gtw <branch>"; return 1 }

  # 1. repo information
  local root=$(git rev-parse --show-toplevel 2>/dev/null) \
    || { echo "❌  Not inside a Git repository"; return 1 }
  local repo=${root:t}                     # basename of repo
  local safe_branch=${branch//\//-}        # / → -
  local target=${root:h}/${repo}-${safe_branch}

  # 2. existing tree?
  if [[ -d $target ]]; then
    echo "✔ Work-tree already exists → cd $target"
    cd "$target"
    return
  fi

  # 3. create tree (branch new or existing)
  if git show-ref --quiet "refs/heads/$branch"; then
    git worktree add "$target" "$branch"
  else
    # detect default remote branch (falls back to main)
    local def=$(git symbolic-ref --quiet --short refs/remotes/origin/HEAD 2>/dev/null \
                 | cut -d/ -f2)
    [[ -z $def ]] && def=main
    git worktree add -b "$branch" "$target" origin/$def
  fi

  cd "$target"
  echo "✅  Now inside $target"
}

# ----------------------------------------------------
# rmwt  – remove a git work-tree
# ----------------------------------------------------
rmwt () {
  local target=$1

  # If no arg: are we *in* a work-tree folder that matches "<repo>-<branch>"?
  if [[ -z $target ]] && git rev-parse --git-path . &>/dev/null; then
    local root=$(git rev-parse --show-toplevel)
    local base=${root:t}
    [[ $base == *-* ]] && target=$root
  fi

  [[ -z $target ]] && { echo "Usage: rmwt [worktree-path]"; return 1 }
  [[ ! -d $target/.git ]] && { echo "❌  $target is not a git dir"; return 1 }

  read -q "REPLY?⚠️  Remove work-tree $target ? [y/N] " || { echo; return 1 }
  echo
  git worktree remove --force "$target" && rm -rf "$target"
  echo "🗑  Work-tree removed"
}

# ----------------------------------------------------
# tab-completion for gtw  (local + remote branches)
# ----------------------------------------------------
_gtw_complete () {
  local -a branches
  branches=(${(f)"$(git for-each-ref --format='%(refname:short)' \
                  refs/heads refs/remotes | grep -v '^HEAD')"})
  _describe 'branch' branches
}
compdef _gtw_complete gtw

# ~/.zshrc ────────────────────────────────────────────────────────────────────
dg_db_tunnel () {
  local stage="${1:-umg79}"
  local profile="${2:-production}"

  local base="$HOME/Dev/dg/dg-stage-deploy"
  local workdir="$base/.rds-tunnel"               # folder that contains Makefile
  local kube="$base/.eks-tunnel/kubeconfig-${stage}.yml"

  [[ -d "$workdir" ]] || { echo "[db-tunnel] workdir not found: $workdir"; return 1; }

  # colour for banner (red when the stage looks like production)
  local colour reset msg
  reset=$'\e[0m'
  if [[ "$stage" =~ (prod|umg79) ]]; then
    colour=$'\e[1;31m'; msg="💣 PRODUCTION"
  else
    colour=$'\e[1;32m'; msg="staging/test system"
  fi

  #############################################################################
  # Everything inside this parenthesis is a sub-shell:
  # • we cd into $workdir
  # • we set/alter env vars
  # • when we exit, PWD and env of the caller are untouched
  #############################################################################
  (
    cd "$workdir" || exit 1
    export KUBECONFIG="$kube"

    # helper to read Make variables silently
    local namespace host
    namespace=$(STAGE="$stage" make --silent -f - <<< 'print-%:\n\t@printf $($*)\n' print-NAMESPACE)
    host=$(STAGE="$stage"  make --silent -f - <<< 'print-%:\n\t@printf $($*)\n' print-SOCAT_ARGS)
    host=${host#tcp-connect:}; host=${host%%:*}

    # ── banner ──────────────────────────────────────────────────────────────
    printf '\n%s┌──────────────────────────────────────────────────────────┐%s\n' "$colour" "$reset"
    printf '%s│  Connected to %-43s│%s\n'   "$colour" "$msg"       "$reset"
    printf '%s│  stage     : %-43s│%s\n'     "$colour" "$stage"     "$reset"
    printf '%s│  profile   : %-43s│%s\n'     "$colour" "$profile"   "$reset"
    printf '%s│  namespace : %-43s│%s\n'     "$colour" "$namespace" "$reset"
    printf '%s│  host      : %-43s│%s\n'     "$colour" "$host"      "$reset"
    printf '%s└──────────────────────────────────────────────────────────┘%s\n\n' "$colour" "$reset"

    # ── cleanup handler (EXIT + Ctrl-C) ────────────────────────────────────
    cleanup() {
      printf '\n[%sdb-tunnel%s] cleaning up …\n' "$colour" "$reset"
      STAGE="$stage" AWS_PROFILE="$profile" make --silent stop-db-tunnel || true
    }
    trap cleanup EXIT INT TERM

    # ── start pod and port-forward (blocks) ────────────────────────────────
    STAGE="$stage" AWS_PROFILE="$profile" make --silent start-db-tunnel
    STAGE="$stage" AWS_PROFILE="$profile" make --silent port-forward-db-tunnel
  )
}

# ──────────────────────────────────────────────────────────────────────────────
#  db-dump  [stage] [aws_profile]
# ──────────────────────────────────────────────────────────────────────────────
# Default stage  : umg79
# Default profile: production
# Produces       : <namespace>-YYYY-MM-DD.sql in the *calling* directory
# ──────────────────────────────────────────────────────────────────────────────
dg_db_dump () {
  local stage="${1:-umg79}"
  local profile="${2:-production}"

  # directories
  local tunnel_dir="$HOME/Dev/dg/dg-stage-deploy/.rds-tunnel"
  local kube="$HOME/Dev/dg/dg-stage-deploy/.eks-tunnel/kubeconfig-${stage}.yml"

  (
    # remember where the user is, then cd into the tunnel dir
    local caller_cwd="$PWD"
    cd "$tunnel_dir" || { echo "❌  Cannot cd into $tunnel_dir" >&2; exit 1; }

    # ────────────────────────── K8s config ──────────────────────────
    export KUBECONFIG="$kube"

    # 1. start the DB tunnel pod
    STAGE="$stage" AWS_PROFILE="$profile"  make start-db-tunnel

    # 2. port-forward in the background
    STAGE="$stage" AWS_PROFILE="$profile"  make port-forward-db-tunnel &
    local pf_pid=$!

    sleep 3

    # 3. get the full ecto URL (ecto://user:pass@host:port/db)
    local url
    url="$(STAGE="$stage" AWS_PROFILE="$profile" make --silent snatch-db-url)"

    # 4. pull the individual parts out of the URL
    #    scheme://user:pass@host:port/dbname
    local no_scheme="${url#*://}"          # user:pass@host:port/db
    local creds="${no_scheme%%@*}"         # user:pass
    local rest="${no_scheme#*@}"           # host:port/db

    local user="${creds%%:*}"              # user
    local pass="${creds#*:}"               # pass

    local hostport="${rest%%/*}"           # host:port/db
    local host="${hostport%%:*}"           # host

    # set port based on stage (matching Makefile logic)
    local port
    if [[ "$stage" == "umg79" ]]; then
      port=5433
    else
      port=5434
    fi

    local db="${rest#*/}"                  # dbname (may contain %... → leave as-is)

    # 5. create a temporary .pgpass file for non-interactive auth
    local pgpass_file
    pgpass_file="$(mktemp)"
    # Use 127.0.0.1 in .pgpass since pg_dump connects to localhost
    echo "127.0.0.1:${port}:${db}:${user}:${pass}" > "$pgpass_file"
    chmod 600 "$pgpass_file"

    # log connection info
    echo "🔗 Database connection details:"
    echo "   Connect to: 127.0.0.1:${port}"
    echo "   Database: ${db}"
    echo "   User: ${user}"
    echo "   .pgpass entry: 127.0.0.1:${port}:${db}:${user}:***"
    echo "   .pgpass file: ${pgpass_file}"

    # cleanup handler for Ctrl+C and exit
    cleanup() {
      echo "Cleaning up..."
      rm -f "$pgpass_file" 2>/dev/null

      # Kill port-forward process and its children
      if [[ -n "$pf_pid" ]]; then
        kill "$pf_pid" 2>/dev/null || true
        # Also kill any remaining kubectl port-forward processes on this port
        pkill -f "kubectl port-forward.*${port}:5432" 2>/dev/null || true
      fi

      # Stop the tunnel pod
      STAGE="$stage" AWS_PROFILE="$profile" make stop-db-tunnel 2>/dev/null || true

      # Wait a moment for port to be freed
      sleep 1
    }
    trap cleanup EXIT INT TERM

    # 6. get namespace for output filename (simpler approach)
    local namespace
    if [[ "$stage" == "umg79" ]]; then
      namespace="dg-stage-prod"
    elif [[ "$stage" == "umg79hybrid" ]]; then
      namespace="argo-workflows-prod"
    else
      namespace="dg-stage-staging"
    fi

    # 7. run sanitized dump inline (PGPASSFILE makes pg_dump skip the prompt)
    PGPASSFILE="$pgpass_file" pg_dump -h 127.0.0.1 -p "$port" -U "$user" -d "$db" \
        --exclude-table-data=users \
        --exclude-table-data=device_identifiers \
        --exclude-table-data=devices \
        --exclude-table-data=favorites \
        --exclude-table-data=live_concert_reminders \
        --exclude-table-data=playback_progress \
        --exclude-table-data=postal_addresses \
        --exclude-table-data=tickets \
        --exclude-table-data=user_codes \
        --exclude-table-data=user_push_endpoints \
        --exclude-table-data=voucher_redemptions \
        --exclude-table-data=vouchers \
        --exclude-table-data=payments \
        --no-owner \
        --no-privileges \
        --clean \
        --if-exists > "${namespace}-$(date '+%Y-%m-%d').sql"

    # 8. cleanup (trap will also handle this, but explicit is better)
    cleanup

    # 8. return to the directory from which the user invoked db-dump
    cd "$caller_cwd"
  )
}


