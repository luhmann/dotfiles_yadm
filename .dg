# aj = audio jobs
dg_aj () {
   KUBECONFIG="/Users/jfd/Dev/dg/dg-stage-deploy/.eks-tunnel/kubeconfig-umg79_INGEST.yml" AWS_PROFILE=production ARGO_NAMESPACE=ingest-prod argo "$@"
}

# get failed audio jobs and display the upcs
dg_af () {
    local workflow_status="${1:-Failed}"
    dg_aj list --status "$workflow_status" -o json | jq -r '
def fmt_kvs(o): (o // {}) | to_entries | map("\(.key)=\(.value)") | join(",");
def humandur($s):
  if $s == null then ""
  elif $s < 0 then "-" + humandur(-$s)
  elif $s >= 3600 then
    "\((($s/3600)|floor))h" +
    (if (($s%3600)/60|floor) > 0 then "\(((($s%3600)/60)|floor))m" else "" end)
  elif $s >= 60 then "\((($s/60)|floor))m"
  else "\(($s|floor))s"
  end;
def pick_items: if type=="object" and has("items") then .items else . end;

pick_items
| map({
    name:        .metadata.name,
    status:      .status.phase,
    age_s:       (now - (.metadata.creationTimestamp | fromdateiso8601)),
    dur_s:       (.status.duration // .status.estimatedDuration //
                 ((.status.finishedAt|fromdateiso8601) - (.status.startedAt|fromdateiso8601))),
    started:     .status.startedAt,
    finished:    .status.finishedAt,
    labels:      fmt_kvs(.metadata.labels),
    annotations: fmt_kvs(.metadata.annotations)
  })
| (["NAME","STATUS","AGE","DURATION","STARTED","FINISHED","LABELS","ANNOTATIONS"] | @tsv),
  (.[] | [
      .name,
      .status,
      humandur(.age_s),
      humandur(.dur_s),
      (.started // ""),
      (.finished // ""),
      .labels,
      .annotations
    ] | @tsv)
' | column -t -s $'\t'
}

dg_vf () {
    local workflow_status="${1:-Failed}"
    dg_vj list --status "$workflow_status" -o json | jq -r '
def fmt_kvs(o): (o // {}) | to_entries | map("\(.key)=\(.value)") | join(",");
def humandur($s):
  if $s == null then ""
  elif $s < 0 then "-" + humandur(-$s)
  elif $s >= 3600 then
    "\((($s/3600)|floor))h" +
    (if (($s%3600)/60|floor) > 0 then "\(((($s%3600)/60)|floor))m" else "" end)
  elif $s >= 60 then "\((($s/60)|floor))m"
  else "\(($s|floor))s"
  end;
def pick_items: if type=="object" and has("items") then .items else . end;

pick_items
| map({
    name:        .metadata.name,
    status:      .status.phase,
    age_s:       (now - (.metadata.creationTimestamp | fromdateiso8601)),
    dur_s:       (.status.duration // .status.estimatedDuration //
                 ((.status.finishedAt|fromdateiso8601) - (.status.startedAt|fromdateiso8601))),
    started:     .status.startedAt,
    finished:    .status.finishedAt,
    labels:      fmt_kvs(.metadata.labels),
    annotations: fmt_kvs(.metadata.annotations)
  })
| (["NAME","STATUS","AGE","DURATION","STARTED","FINISHED","LABELS","ANNOTATIONS"] | @tsv),
  (.[] | [
      .name,
      .status,
      humandur(.age_s),
      humandur(.dur_s),
      (.started // ""),
      (.finished // ""),
      .labels,
      .annotations
    ] | @tsv)
' | column -t -s $'\t'
}

# get a single job and display the reason it failed
dg_ar() {
    dg_aj get "$1" -o json | jq '.status.nodes[] | select(.phase=="Failed") | {displayName, message}'
}

# vj = video jobs
dg_vj () {
   KUBECONFIG="/Users/jfd/Dev/dg/dg-stage-deploy/.eks-tunnel/kubeconfig-umg79_INGEST.yml" AWS_PROFILE=production ARGO_NAMESPACE=repackage-prod argo "$@"
}


dg_db_tunnel () {
  local stage="${1:-umg79}"
  local profile="${2:-production}"

  local base="$HOME/Dev/dg/dg-stage-deploy"
  local workdir="$base/.rds-tunnel"               # folder that contains Makefile
  local kube="$base/.eks-tunnel/kubeconfig-${stage}.yml"

  # Validate directories exist
  if [[ ! -d "$workdir" ]]; then
    echo "[db-tunnel] âŒ workdir not found: $workdir"
    return 1
  fi

  if [[ ! -f "$kube" ]]; then
    echo "[db-tunnel] âŒ kubeconfig not found: $kube"
    return 1
  fi

  # colour for banner (red when the stage looks like production)
  local colour reset msg
  reset=$'\e[0m'
  if [[ "$stage" =~ (umg79) ]]; then
    colour=$'\e[1;31m'; msg="ğŸ’£ PRODUCTION"
  else
    colour=$'\e[1;32m'; msg="staging/test system"
  fi

  (
    cd "$workdir" || exit 1
    export KUBECONFIG="$kube"

    # Variables for cleanup tracking
    local tunnel_started=false
    local pf_pid=""
    local namespace=""
    local port=""

    # Get namespace and port for this stage
    if [[ "$stage" == "umg79" ]]; then
      namespace="dg-stage-prod"
      port=5433
    elif [[ "$stage" == "umg79hybrid" ]]; then
      namespace="argo-workflows-prod"
      # port=5435
    else
      namespace="dg-stage-staging"
      port=5434
    fi

    cleanup() {
      printf '\n[%sdb-tunnel%s] ğŸ§¹ Cleaning up...\n' "$colour" "$reset"

      # Kill port-forward process with retry
      if [[ -n "$pf_pid" ]]; then
        printf '[%sdb-tunnel%s]    ğŸ”Œ Stopping port-forward (PID: %s)...\n' "$colour" "$reset" "$pf_pid"
        kill "$pf_pid" 2>/dev/null || true
        sleep 2

        # Force kill if still running
        if kill -0 "$pf_pid" 2>/dev/null; then
          printf '[%sdb-tunnel%s]    ğŸ”¨ Force killing port-forward...\n' "$colour" "$reset"
          kill -9 "$pf_pid" 2>/dev/null || true
        fi
      fi

      # Force kill any remaining port-forwards on this port
      if [[ -n "$port" ]] && pgrep -f "kubectl port-forward.*${port}:5432" >/dev/null 2>&1; then
        printf '[%sdb-tunnel%s]    ğŸ”¨ Force killing remaining port-forwards on port %s...\n' "$colour" "$reset" "$port"
        pkill -9 -f "kubectl port-forward.*${port}:5432" 2>/dev/null || true
      fi

      # Stop tunnel pod if we started it
      if [[ "$tunnel_started" == "true" ]]; then
        printf '[%sdb-tunnel%s]    ğŸš‡ Stopping tunnel pod...\n' "$colour" "$reset"
        if STAGE="$stage" AWS_PROFILE="$profile" make --silent stop-db-tunnel 2>/dev/null; then
          printf '[%sdb-tunnel%s]    âœ“ Tunnel pod stopped\n' "$colour" "$reset"
        else
          printf '[%sdb-tunnel%s]    âš ï¸  Warning: Failed to stop tunnel pod rds-tunnel-%s\n' "$colour" "$reset" "$USER"
        fi
      fi

      # Wait for port to be freed
      printf '[%sdb-tunnel%s]    â³ Waiting for port to be freed...\n' "$colour" "$reset"
      sleep 3
      printf '[%sdb-tunnel%s] âœ… Cleanup complete\n' "$colour" "$reset"
    }
    trap cleanup EXIT INT TERM

    # â”€â”€ banner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    printf '\n%sâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”%s\n' "$colour" "$reset"
    printf '%sâ”‚  Connected to %-43sâ”‚%s\n'   "$colour" "$msg"       "$reset"
    printf '%sâ”‚  stage     : %-43sâ”‚%s\n'     "$colour" "$stage"     "$reset"
    printf '%sâ”‚  profile   : %-43sâ”‚%s\n'     "$colour" "$profile"   "$reset"
    printf '%sâ”‚  namespace : %-43sâ”‚%s\n'     "$colour" "$namespace" "$reset"
    printf '%sâ”‚  port      : %-43sâ”‚%s\n'     "$colour" "$port"      "$reset"
    printf '%sâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜%s\n\n' "$colour" "$reset"

    # â”€â”€ start pod with error handling â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    printf '[%sdb-tunnel%s] ğŸš‡ Starting tunnel pod...\n' "$colour" "$reset"
    if ! STAGE="$stage" AWS_PROFILE="$profile" make --silent start-db-tunnel; then
      printf '[%sdb-tunnel%s] âŒ Failed to start tunnel pod\n' "$colour" "$reset"
      exit 1
    fi
    tunnel_started=true
    printf '[%sdb-tunnel%s] âœ“ Tunnel pod started\n' "$colour" "$reset"

    # Wait for tunnel pod to be ready
    printf '[%sdb-tunnel%s] â³ Waiting for tunnel pod to be ready...\n' "$colour" "$reset"
    if ! kubectl wait --namespace "$namespace" --for=condition=Ready pod/rds-tunnel-"$USER" --timeout=60s; then
      printf '[%sdb-tunnel%s] âŒ Tunnel pod failed to become ready within 60 seconds\n' "$colour" "$reset"
      exit 1
    fi
    printf '[%sdb-tunnel%s] âœ“ Tunnel pod is ready\n' "$colour" "$reset"

    # â”€â”€ start port-forward in background â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    printf '[%sdb-tunnel%s] ğŸ”Œ Starting port-forward to localhost:%s...\n' "$colour" "$reset" "$port"
    STAGE="$stage" AWS_PROFILE="$profile" make --silent port-forward-db-tunnel &
    pf_pid=$!

    # Wait for port-forward to be established with timeout
    printf '[%sdb-tunnel%s] â³ Waiting for port-forward to establish...\n' "$colour" "$reset"
    local timeout=60
    local wait_interval=2
    while [[ $timeout -gt 0 ]]; do
      # Check if port is available using netcat
      if command -v nc >/dev/null 2>&1 && nc -z 127.0.0.1 "$port" 2>/dev/null; then
        printf '[%sdb-tunnel%s] âœ“ Port-forward established on localhost:%s\n' "$colour" "$reset" "$port"
        break
      fi

      # Alternative check using /dev/tcp if nc is not available
      if (exec 3<>/dev/tcp/127.0.0.1/"$port") 2>/dev/null; then
        exec 3>&-
        printf '[%sdb-tunnel%s] âœ“ Port-forward established on localhost:%s\n' "$colour" "$reset" "$port"
        break
      fi

      # Check if port-forward process is still running
      if ! kill -0 "$pf_pid" 2>/dev/null; then
        printf '[%sdb-tunnel%s] âŒ Port-forward process died unexpectedly\n' "$colour" "$reset"
        exit 1
      fi

      printf '[%sdb-tunnel%s]    Still waiting... (%ss remaining)\n' "$colour" "$reset" "$timeout"
      sleep $wait_interval
      ((timeout-=wait_interval))
    done

    if [[ $timeout -le 0 ]]; then
      printf '[%sdb-tunnel%s] âŒ Port-forward failed to establish within 60 seconds\n' "$colour" "$reset"
      exit 1
    fi

    # â”€â”€ connection ready â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    printf '\n%sâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”%s\n' "$colour" "$reset"
    printf '%sâ”‚  ğŸ¯ TUNNEL READY - Connect to localhost:%-15s â”‚%s\n' "$colour" "$port" "$reset"
    printf '%sâ”‚                                                          â”‚%s\n' "$colour" "$reset"
    printf '%sâ”‚  Example psql command:                                   â”‚%s\n' "$colour" "$reset"
    printf '%sâ”‚  psql -h 127.0.0.1 -p %-5s -U api -d dgstage -W         â”‚%s\n' "$colour" "$port" "$reset"
    printf '%sâ”‚                                                          â”‚%s\n' "$colour" "$reset"
    printf '%sâ”‚  Press Ctrl+C to stop the tunnel                        â”‚%s\n' "$colour" "$reset"
    printf '%sâ””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜%s\n\n' "$colour" "$reset"

    # â”€â”€ wait for user interrupt (blocks) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    printf '[%sdb-tunnel%s] ğŸ”„ Tunnel active. Press Ctrl+C to stop...\n' "$colour" "$reset"

    # Wait for the port-forward process to exit (either by user interrupt or process death)
    wait "$pf_pid" 2>/dev/null || true

    # If we reach here, the port-forward process has ended
    printf '\n[%sdb-tunnel%s] ğŸ›‘ Port-forward process ended\n' "$colour" "$reset"

    # Cleanup will be called automatically by trap
  )
}

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#  db-dump  [stage] [aws_profile]
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Default stage  : umg79
# Default profile: production
# Produces       : <namespace>-YYYY-MM-DD.sql in the *calling* directory
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
dg_db_dump () {
  local stage="${1:-umg79}"
  local profile="${2:-production}"

  # directories
  local tunnel_dir="$HOME/Dev/dg/dg-stage-deploy/.rds-tunnel"
  local kube="$HOME/Dev/dg/dg-stage-deploy/.eks-tunnel/kubeconfig-${stage}.yml"

  (
    # remember where the user is, then cd into the tunnel dir
    local caller_cwd="$PWD"
    cd "$tunnel_dir" || { echo "âŒ  Cannot cd into $tunnel_dir" >&2; exit 1; }

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ K8s config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    export KUBECONFIG="$kube"

    # Get namespace, port, database, and user for this stage
    local namespace port db_name db_user
    if [[ "$stage" == "umg79" ]]; then
      namespace="dg-stage-prod"
      port=5433
      db_name="dgstage"
      db_user="dg_stage_read_only"
    elif [[ "$stage" == "umg79hybrid" ]]; then
      namespace="argo-workflows-prod"
      port=5435
      db_name="dgstage"
      db_user="argo"
    else
      namespace="dg-stage-staging"
      port=5434
      db_name="dgstageimport"
      db_user="dg_stage_read_only"
    fi

    # Variables for cleanup
    local pf_pid=""
    local pgpass_file=""
    local tunnel_started=false

    # Enhanced cleanup handler for Ctrl+C and exit
    cleanup() {
      echo "ğŸ§¹ Cleaning up..."

      # Remove .pgpass file
      if [[ -n "$pgpass_file" && -f "$pgpass_file" ]]; then
        rm -f "$pgpass_file" 2>/dev/null
        echo "   âœ“ Removed .pgpass file"
      fi

      # Kill port-forward process with retry
      if [[ -n "$pf_pid" ]]; then
        echo "   ğŸ”Œ Stopping port-forward (PID: $pf_pid)..."
        kill "$pf_pid" 2>/dev/null || true
        sleep 2

        # Force kill if still running
        if kill -0 "$pf_pid" 2>/dev/null; then
          echo "   ğŸ”¨ Force killing port-forward..."
          kill -9 "$pf_pid" 2>/dev/null || true
        fi
      fi

      # Force kill any remaining port-forwards on this port
      if pgrep -f "kubectl port-forward.*${port}:5432" >/dev/null 2>&1; then
        echo "   ğŸ”¨ Force killing remaining port-forwards..."
        pkill -9 -f "kubectl port-forward.*${port}:5432" 2>/dev/null || true
      fi

      # Stop the tunnel pod if we started it
      if [[ "$tunnel_started" == "true" ]]; then
        echo "   ğŸš‡ Stopping tunnel pod..."
        if STAGE="$stage" AWS_PROFILE="$profile" make stop-db-tunnel 2>/dev/null; then
          echo "   âœ“ Tunnel pod stopped"
        else
          echo "   âš ï¸  Warning: Failed to stop tunnel pod rds-tunnel-$USER"
        fi
      fi

      # Wait for port to be freed
      echo "   â³ Waiting for port to be freed..."
      sleep 3
      echo "âœ… Cleanup complete"
    }
    trap cleanup EXIT INT TERM

    # 1. Start the DB tunnel pod with error handling
    echo "ğŸš‡ Starting DB tunnel pod..."
    if ! STAGE="$stage" AWS_PROFILE="$profile" make start-db-tunnel; then
      echo "âŒ Failed to start DB tunnel pod"
      exit 1
    fi
    tunnel_started=true
    echo "âœ“ Tunnel pod started"

    # Wait for tunnel pod to be ready
    echo "â³ Waiting for tunnel pod to be ready..."
    if ! kubectl wait --namespace "$namespace" --for=condition=Ready pod/rds-tunnel-"$USER" --timeout=60s; then
      echo "âŒ Tunnel pod failed to become ready within 60 seconds"
      exit 1
    fi
    echo "âœ“ Tunnel pod is ready"

    # 2. Start port-forward in the background
    echo "ğŸ”Œ Starting port-forward to localhost:$port..."
    STAGE="$stage" AWS_PROFILE="$profile" make port-forward-db-tunnel &
    pf_pid=$!

    # Wait for port-forward to be established with timeout
    echo "â³ Waiting for port-forward to establish..."
    local timeout=60
    local wait_interval=2
    while [[ $timeout -gt 0 ]]; do
      # Check if port is available using netcat
      if command -v nc >/dev/null 2>&1 && nc -z 127.0.0.1 "$port" 2>/dev/null; then
        echo "âœ“ Port-forward established on localhost:$port"
        break
      fi

      # Alternative check using /dev/tcp if nc is not available
      if (exec 3<>/dev/tcp/127.0.0.1/"$port") 2>/dev/null; then
        exec 3>&-
        echo "âœ“ Port-forward established on localhost:$port"
        break
      fi

      # Check if port-forward process is still running
      if ! kill -0 "$pf_pid" 2>/dev/null; then
        echo "âŒ Port-forward process died unexpectedly"
        exit 1
      fi

      echo "   Still waiting... (${timeout}s remaining)"
      sleep $wait_interval
      ((timeout-=wait_interval))
    done

    if [[ $timeout -le 0 ]]; then
      echo "âŒ Port-forward failed to establish within 60 seconds"
      exit 1
    fi

    # 3. Get database password
    echo "ğŸ”‘ Retrieving database password..."
    local password
    if ! password="$(STAGE="$stage" AWS_PROFILE="$profile" make --silent snatch-db-url 2>/dev/null)"; then
      echo "âŒ Failed to retrieve database password"
      exit 1
    fi

    if [[ -z "$password" ]]; then
      echo "âŒ Database password is empty"
      exit 1
    fi

    echo "âœ“ Password retrieved (${#password} characters)"

    # 4. Create a temporary .pgpass file for non-interactive auth
    pgpass_file="$(mktemp)"
    if [[ $? -ne 0 || -z "$pgpass_file" ]]; then
      echo "âŒ Failed to create temporary .pgpass file"
      exit 1
    fi

    # Format: hostname:port:database:username:password
    echo "127.0.0.1:${port}:${db_name}:${db_user}:${password}" > "$pgpass_file"
    chmod 600 "$pgpass_file"

    # Log connection info (without password)
    echo "ğŸ”— Database connection details:"
    echo "   Connect to: 127.0.0.1:${port}"
    echo "   Database: ${db_name}"
    echo "   User: ${db_user}"
    echo "   Password: [${#password} characters]"
    echo "   .pgpass file: ${pgpass_file}"

    # Test database connection before proceeding
    echo "ğŸ§ª Testing database connection..."
    if ! PGPASSFILE="$pgpass_file" pg_isready -h 127.0.0.1 -p "$port" -U "$db_user" -d "$db_name" -q; then
      echo "âŒ Database connection test failed"
      exit 1
    fi
    echo "âœ“ Database connection successful"

    # 7. Run sanitized dump inline (PGPASSFILE makes pg_dump skip the prompt)
    local output_file="${namespace}-$(date '+%Y-%m-%d').sql"
    echo "ğŸ“¦ Starting database dump to: $output_file"
    echo "   This may take several minutes..."

    if ! PGPASSFILE="$pgpass_file" pg_dump -h 127.0.0.1 -p "$port" -U "$db_user" -d "$db_name" \
        --exclude-table-data=users \
        --exclude-table-data=device_identifiers \
        --exclude-table-data=devices \
        --exclude-table-data=favorites \
        --exclude-table-data=live_concert_reminders \
        --exclude-table-data=playback_progress \
        --exclude-table-data=postal_addresses \
        --exclude-table-data=tickets \
        --exclude-table-data=user_codes \
        --exclude-table-data=user_push_endpoints \
        --exclude-table-data=voucher_redemptions \
        --exclude-table-data=vouchers \
        --exclude-table-data=payments \
        --no-owner \
        --no-privileges \
        --clean \
        --if-exists > "$caller_cwd/$output_file"; then
      echo "âŒ Database dump failed"
      exit 1
    fi

    echo "âœ… Database dump completed successfully!"
    echo "   Output file: $caller_cwd/$output_file"
    echo "   File size: $(du -h "$caller_cwd/$output_file" | cut -f1)"

    # Cleanup will be called automatically by trap
  )
}

dg_db_dump_full () {
  local stage="${1:-umg79}"
  local profile="${2:-production}"

  # directories
  local tunnel_dir="$HOME/Dev/dg/dg-stage-deploy/.rds-tunnel"
  local kube="$HOME/Dev/dg/dg-stage-deploy/.eks-tunnel/kubeconfig-${stage}.yml"

  (
    # remember where the user is, then cd into the tunnel dir
    local caller_cwd="$PWD"
    cd "$tunnel_dir" || { echo "âŒ  Cannot cd into $tunnel_dir" >&2; exit 1; }

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ K8s config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    export KUBECONFIG="$kube"

    # Get namespace, port, database, and user for this stage
    local namespace port db_name db_user
    if [[ "$stage" == "umg79" ]]; then
      namespace="dg-stage-prod"
      port=5433
      db_name="dgstage"
      db_user="dg_stage_read_only"
    elif [[ "$stage" == "umg79hybrid" ]]; then
      namespace="argo-workflows-prod"
      port=5435
      db_name="dgstage"
      db_user="argo"
    else
      namespace="dg-stage-staging"
      port=5434
      db_name="dgstageimport"
      db_user="dg_stage_read_only"
    fi

    # Variables for cleanup
    local pf_pid=""
    local pgpass_file=""
    local tunnel_started=false

    # Enhanced cleanup handler for Ctrl+C and exit
    cleanup() {
      echo "ğŸ§¹ Cleaning up..."

      # Remove .pgpass file
      if [[ -n "$pgpass_file" && -f "$pgpass_file" ]]; then
        rm -f "$pgpass_file" 2>/dev/null
        echo "   âœ“ Removed .pgpass file"
      fi

      # Kill port-forward process with retry
      if [[ -n "$pf_pid" ]]; then
        echo "   ğŸ”Œ Stopping port-forward (PID: $pf_pid)..."
        kill "$pf_pid" 2>/dev/null || true
        sleep 2

        # Force kill if still running
        if kill -0 "$pf_pid" 2>/dev/null; then
          echo "   ğŸ”¨ Force killing port-forward..."
          kill -9 "$pf_pid" 2>/dev/null || true
        fi
      fi

      # Force kill any remaining port-forwards on this port
      if pgrep -f "kubectl port-forward.*${port}:5432" >/dev/null 2>&1; then
        echo "   ğŸ”¨ Force killing remaining port-forwards..."
        pkill -9 -f "kubectl port-forward.*${port}:5432" 2>/dev/null || true
      fi

      # Stop the tunnel pod if we started it
      if [[ "$tunnel_started" == "true" ]]; then
        echo "   ğŸš‡ Stopping tunnel pod..."
        if STAGE="$stage" AWS_PROFILE="$profile" make stop-db-tunnel 2>/dev/null; then
          echo "   âœ“ Tunnel pod stopped"
        else
          echo "   âš ï¸  Warning: Failed to stop tunnel pod rds-tunnel-$USER"
        fi
      fi

      # Wait for port to be freed
      echo "   â³ Waiting for port to be freed..."
      sleep 3
      echo "âœ… Cleanup complete"
    }
    trap cleanup EXIT INT TERM

    # 1. Start the DB tunnel pod with error handling
    echo "ğŸš‡ Starting DB tunnel pod..."
    if ! STAGE="$stage" AWS_PROFILE="$profile" make start-db-tunnel; then
      echo "âŒ Failed to start DB tunnel pod"
      exit 1
    fi
    tunnel_started=true
    echo "âœ“ Tunnel pod started"

    # Wait for tunnel pod to be ready
    echo "â³ Waiting for tunnel pod to be ready..."
    if ! kubectl wait --namespace "$namespace" --for=condition=Ready pod/rds-tunnel-"$USER" --timeout=60s; then
      echo "âŒ Tunnel pod failed to become ready within 60 seconds"
      exit 1
    fi
    echo "âœ“ Tunnel pod is ready"

    # 2. Start port-forward in the background
    echo "ğŸ”Œ Starting port-forward to localhost:$port..."
    STAGE="$stage" AWS_PROFILE="$profile" make port-forward-db-tunnel &
    pf_pid=$!

    # Wait for port-forward to be established with timeout
    echo "â³ Waiting for port-forward to establish..."
    local timeout=60
    local wait_interval=2
    while [[ $timeout -gt 0 ]]; do
      # Check if port is available using netcat
      if command -v nc >/dev/null 2>&1 && nc -z 127.0.0.1 "$port" 2>/dev/null; then
        echo "âœ“ Port-forward established on localhost:$port"
        break
      fi

      # Alternative check using /dev/tcp if nc is not available
      if (exec 3<>/dev/tcp/127.0.0.1/"$port") 2>/dev/null; then
        exec 3>&-
        echo "âœ“ Port-forward established on localhost:$port"
        break
      fi

      # Check if port-forward process is still running
      if ! kill -0 "$pf_pid" 2>/dev/null; then
        echo "âŒ Port-forward process died unexpectedly"
        exit 1
      fi

      echo "   Still waiting... (${timeout}s remaining)"
      sleep $wait_interval
      ((timeout-=wait_interval))
    done

    if [[ $timeout -le 0 ]]; then
      echo "âŒ Port-forward failed to establish within 60 seconds"
      exit 1
    fi

    # 3. Get database password
    echo "ğŸ”‘ Retrieving database password..."
    local password
    if ! password="$(STAGE="$stage" AWS_PROFILE="$profile" make --silent snatch-db-url 2>/dev/null)"; then
      echo "âŒ Failed to retrieve database password"
      exit 1
    fi

    if [[ -z "$password" ]]; then
      echo "âŒ Database password is empty"
      exit 1
    fi

    echo "âœ“ Password retrieved (${#password} characters)"

    # 4. Create a temporary .pgpass file for non-interactive auth
    pgpass_file="$(mktemp)"
    if [[ $? -ne 0 || -z "$pgpass_file" ]]; then
      echo "âŒ Failed to create temporary .pgpass file"
      exit 1
    fi

    # Format: hostname:port:database:username:password
    echo "127.0.0.1:${port}:${db_name}:${db_user}:${password}" > "$pgpass_file"
    chmod 600 "$pgpass_file"

    # Log connection info (without password)
    echo "ğŸ”— Database connection details:"
    echo "   Connect to: 127.0.0.1:${port}"
    echo "   Database: ${db_name}"
    echo "   User: ${db_user}"
    echo "   Password: [${#password} characters]"
    echo "   .pgpass file: ${pgpass_file}"

    # Test database connection before proceeding
    echo "ğŸ§ª Testing database connection..."
    if ! PGPASSFILE="$pgpass_file" pg_isready -h 127.0.0.1 -p "$port" -U "$db_user" -d "$db_name" -q; then
      echo "âŒ Database connection test failed"
      exit 1
    fi
    echo "âœ“ Database connection successful"

    # 7. Run sanitized dump inline (PGPASSFILE makes pg_dump skip the prompt)
    local output_file="${namespace}-$(date '+%Y-%m-%d').sql"
    echo "ğŸ“¦ Starting database dump to: $output_file"
    echo "   This may take several minutes..."

    if ! PGPASSFILE="$pgpass_file" pg_dump -h 127.0.0.1 -p "$port" -U "$db_user" -d "$db_name" \
        --no-owner \
        --no-privileges \
        --clean \
        --if-exists > "$caller_cwd/$output_file"; then
      echo "âŒ Database dump failed"
      exit 1
    fi

    echo "âœ… Database dump completed successfully!"
    echo "   Output file: $caller_cwd/$output_file"
    echo "   File size: $(du -h "$caller_cwd/$output_file" | cut -f1)"

    # Cleanup will be called automatically by trap
  )
}
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Default stage  : umg79
# Default profile: production
# Produces       : query-output-YYYY-MM-DD-HHMMSS.csv in the *calling* directory
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
dg_db_query_csv () {
  local query="$1"
  local stage="${2:-umg79}"
  local profile="${3:-production}"

  # Check if query is provided
  if [[ -z "$query" ]]; then
    echo "âŒ SQL query is required as the first parameter"
    echo "Usage: dg_db_query_csv 'SELECT * FROM table_name LIMIT 10' [stage] [profile]"
    return 1
  fi

  # Display the query and ask for confirmation
  echo "ğŸ” SQL Query to execute:"
  echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
  echo "$query"
  echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
  echo ""
  echo "ğŸ¯ Target: Stage '$stage', Profile '$profile'"
  echo ""
  echo -n "â“ Do you want to execute this query? (y/N): "
  read -r REPLY
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "âŒ Query execution cancelled"
    return 1
  fi

  # directories
  local tunnel_dir="$HOME/Dev/dg/dg-stage-deploy/.rds-tunnel"
  local kube="$HOME/Dev/dg/dg-stage-deploy/.eks-tunnel/kubeconfig-${stage}.yml"

  (
    # remember where the user is, then cd into the tunnel dir
    local caller_cwd="$PWD"
    cd "$tunnel_dir" || { echo "âŒ  Cannot cd into $tunnel_dir" >&2; exit 1; }

    # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ K8s config â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    export KUBECONFIG="$kube"

    # Get namespace, port, database, and user for this stage
    local namespace port db_name db_user
    if [[ "$stage" == "umg79" ]]; then
      namespace="dg-stage-prod"
      port=5433
      db_name="dgstage"
      db_user="dg_stage_read_only"
    elif [[ "$stage" == "umg79hybrid" ]]; then
      namespace="argo-workflows-prod"
      port=5435
      db_name="dgstage"
      db_user="argo"
    else
      namespace="dg-stage-staging"
      port=5434
      db_name="dgstageimport"
      db_user="dg_stage_read_only"
    fi

    # Variables for cleanup
    local pf_pid=""
    local pgpass_file=""
    local tunnel_started=false

    # Enhanced cleanup handler for Ctrl+C and exit
    cleanup() {
      echo "ğŸ§¹ Cleaning up..."

      # Remove .pgpass file
      if [[ -n "$pgpass_file" && -f "$pgpass_file" ]]; then
        rm -f "$pgpass_file" 2>/dev/null
        echo "   âœ“ Removed .pgpass file"
      fi

      # Kill port-forward process with retry
      if [[ -n "$pf_pid" ]]; then
        echo "   ğŸ”Œ Stopping port-forward (PID: $pf_pid)..."
        kill "$pf_pid" 2>/dev/null || true
        sleep 2

        # Force kill if still running
        if kill -0 "$pf_pid" 2>/dev/null; then
          echo "   ğŸ”¨ Force killing port-forward..."
          kill -9 "$pf_pid" 2>/dev/null || true
        fi
      fi

      # Force kill any remaining port-forwards on this port
      if pgrep -f "kubectl port-forward.*${port}:5432" >/dev/null 2>&1; then
        echo "   ğŸ”¨ Force killing remaining port-forwards..."
        pkill -9 -f "kubectl port-forward.*${port}:5432" 2>/dev/null || true
      fi

      # Stop the tunnel pod if we started it
      if [[ "$tunnel_started" == "true" ]]; then
        echo "   ğŸš‡ Stopping tunnel pod..."
        if STAGE="$stage" AWS_PROFILE="$profile" make stop-db-tunnel 2>/dev/null; then
          echo "   âœ“ Tunnel pod stopped"
        else
          echo "   âš ï¸  Warning: Failed to stop tunnel pod rds-tunnel-$USER"
        fi
      fi

      # Wait for port to be freed
      echo "   â³ Waiting for port to be freed..."
      sleep 3
      echo "âœ… Cleanup complete"
    }
    trap cleanup EXIT INT TERM

    # 1. Start the DB tunnel pod with error handling
    echo "ğŸš‡ Starting DB tunnel pod..."
    if ! STAGE="$stage" AWS_PROFILE="$profile" make start-db-tunnel; then
      echo "âŒ Failed to start DB tunnel pod"
      exit 1
    fi
    tunnel_started=true
    echo "âœ“ Tunnel pod started"

    # Wait for tunnel pod to be ready
    echo "â³ Waiting for tunnel pod to be ready..."
    if ! kubectl wait --namespace "$namespace" --for=condition=Ready pod/rds-tunnel-"$USER" --timeout=60s; then
      echo "âŒ Tunnel pod failed to become ready within 60 seconds"
      exit 1
    fi
    echo "âœ“ Tunnel pod is ready"

    # 2. Start port-forward in the background
    echo "ğŸ”Œ Starting port-forward to localhost:$port..."
    STAGE="$stage" AWS_PROFILE="$profile" make port-forward-db-tunnel &
    pf_pid=$!

    # Wait for port-forward to be established with timeout
    echo "â³ Waiting for port-forward to establish..."
    local timeout=60
    local wait_interval=2
    while [[ $timeout -gt 0 ]]; do
      # Check if port is available using netcat
      if command -v nc >/dev/null 2>&1 && nc -z 127.0.0.1 "$port" 2>/dev/null; then
        echo "âœ“ Port-forward established on localhost:$port"
        break
      fi

      # Alternative check using /dev/tcp if nc is not available
      if (exec 3<>/dev/tcp/127.0.0.1/"$port") 2>/dev/null; then
        exec 3>&-
        echo "âœ“ Port-forward established on localhost:$port"
        break
      fi

      # Check if port-forward process is still running
      if ! kill -0 "$pf_pid" 2>/dev/null; then
        echo "âŒ Port-forward process died unexpectedly"
        exit 1
      fi

      echo "   Still waiting... (${timeout}s remaining)"
      sleep $wait_interval
      ((timeout-=wait_interval))
    done

    if [[ $timeout -le 0 ]]; then
      echo "âŒ Port-forward failed to establish within 60 seconds"
      exit 1
    fi

    # 3. Get the full ecto URL (ecto://user:pass@host:port/db)
    echo "ğŸ”‘ Retrieving database credentials..."
    local url
    if ! url="$(STAGE="$stage" AWS_PROFILE="$profile" make --silent snatch-db-url)"; then
      echo "âŒ Failed to retrieve database URL"
      exit 1
    fi

    if [[ -z "$url" ]]; then
      echo "âŒ Database URL is empty"
      exit 1
    fi

    # 4. Pull the individual parts out of the URL
    #    scheme://user:pass@host:port/dbname
    local no_scheme="${url#*://}"          # user:pass@host:port/db
    local creds="${no_scheme%%@*}"         # user:pass
    local rest="${no_scheme#*@}"           # host:port/db

    local user="${creds%%:*}"              # user
    local pass="${creds#*:}"               # pass

    local hostport="${rest%%/*}"           # host:port/db
    local host="${hostport%%:*}"           # host

    local db="${rest#*/}"                  # dbname (may contain %... â†’ leave as-is)

    # Validate extracted credentials
    if [[ -z "$user" || -z "$pass" || -z "$db" ]]; then
      echo "âŒ Failed to parse database credentials from URL"
      echo "   User: '$user', Pass: [${#pass} chars], DB: '$db'"
      exit 1
    fi

    # 5. Create a temporary .pgpass file for non-interactive auth
    pgpass_file="$(mktemp)"
    if [[ $? -ne 0 || -z "$pgpass_file" ]]; then
      echo "âŒ Failed to create temporary .pgpass file"
      exit 1
    fi

    # Use 127.0.0.1 in .pgpass since psql connects to localhost
    echo "127.0.0.1:${port}:${db}:${user}:${pass}" > "$pgpass_file"
    chmod 600 "$pgpass_file"

    # Log connection info (without password)
    echo "ğŸ”— Database connection details:"
    echo "   Connect to: 127.0.0.1:${port}"
    echo "   Database: ${db}"
    echo "   User: ${user}"
    echo "   Password: [${#pass} characters]"
    echo "   .pgpass file: ${pgpass_file}"

    # Test database connection before proceeding
    echo "ğŸ§ª Testing database connection..."
    if ! PGPASSFILE="$pgpass_file" pg_isready -h 127.0.0.1 -p "$port" -U "$user" -d "$db" -q; then
      echo "âŒ Database connection test failed"
      exit 1
    fi
    echo "âœ“ Database connection successful"

    # 6. Execute the query and export to CSV
    local timestamp=$(date '+%Y-%m-%d-%H%M%S')
    local output_file="query-output-${timestamp}.csv"
    echo "ğŸ“Š Executing query and exporting to CSV: $output_file"
    echo "   This may take several minutes depending on the query..."

    # Use psql with \copy command to export CSV with headers
    if ! PGPASSFILE="$pgpass_file" psql -h 127.0.0.1 -p "$port" -U "$user" -d "$db" \
        -c "\\copy ($query) TO STDOUT WITH CSV HEADER" > "$caller_cwd/$output_file"; then
      echo "âŒ Query execution failed"
      exit 1
    fi

    echo "âœ… Query executed successfully!"
    echo "   Output file: $caller_cwd/$output_file"
    echo "   File size: $(du -h "$caller_cwd/$output_file" | cut -f1)"
    echo "   Rows exported: $(($(wc -l < "$caller_cwd/$output_file") - 1))"

    # Cleanup will be called automatically by trap
  )
}

function s5cmd_inputs_for_isrc() {
  local env="${ENV:-"production"}"
  local s5cmd_ls_flags=()
  local isrcs=()
  for i in "$@"; do
    if [[ "$i" == "-"* ]]; then
      s5cmd_ls_flags+=($i)
    else
      isrcs+=("${(@s:,:)i}")
    fi
  done

  for isrc in "${isrcs[@]}"; do
    echo -e "\nğŸª£" "Listing input-bucket for s3://dg-vod-input-${env}/${isrc}" >&2
    s5cmd ls "${s5cmd_ls_flags[@]}" "s3://dg-vod-input-${env}/${isrc}"
    echo -e "\nğŸ”‰" "Listing additional audio in s3://stage-ingest-${env}/re-packaging/audio/${isrc}" >&2
    s5cmd ls "${s5cmd_ls_flags[@]}" "s3://stage-ingest-${env}/re-packaging/audio/${isrc}"
  done
}

function s5cmd() {
  local S5CMD=/opt/homebrew/bin/s5cmd
  # shellcheck disable=SC2207 # intentional word splitting for array splitting
  local bucketNames=($(echo "$@" | grep -oE 's3://[^/]+' | sed 's|s3://||g'))
  local numberOfBuckets="${#bucketNames[@]}"
  # echo "ğŸ¤–" "numberOfBuckets: ${numberOfBuckets}, array: '${bucketNames[*]}'"

  case "${numberOfBuckets}" in
    0)
      "${S5CMD}" "$@"
      ;;
    1)
      if [[ "$*" == *" pipe "* ]]; then
        cat | AWS_REGION="$(getBucketRegion "${bucketNames[1]}")" "${S5CMD}" "$@"
      else
        AWS_REGION="$(getBucketRegion "${bucketNames[1]}")" "${S5CMD}" "$@"
      fi
      ;;
    2)
      local new_args=()
      for arg in "$@"; do
        new_args+=("$arg")
        if [[ "$arg" == "cp" || "$arg" == "mv" || "$arg" == "sync" ]]; then
          new_args+=("--source-region" "$(getBucketRegion "${bucketNames[1]}")" "--destination-region" "$(getBucketRegion "${bucketNames[2]}")")
        fi
      done
      "${S5CMD}" "${new_args[@]}"
      ;;
    *)
      echo "Detected ${numberOfBuckets} buckets: '${bucketNames[*]}'. Only up to 2 are supported.";
      return 1;
      ;;
  esac
}

function getBucketRegion() {
  bucketName="${1}"
  # `aws s3api get-bucket-location` would have to be called in the correct region (duh). That's why we use a hack.
  curl -sI -o /dev/null -w '%header{x-amz-bucket-region}' "https://${bucketName}.s3.amazonaws.com"
}


function saws() {
    AWS_PROFILE=default AWS_REGION=us-east-1 aws "$@"
}

function paws() {
    AWS_PROFILE=production AWS_REGION=us-east-1 aws "$@"
}

# Function to get DDEX release info from UPC
ddex-info() {
  local upc="$1"
  local detail_limit="${2:-20}"  # Default to showing first 20 tracks in detail

  if [[ -z "$upc" ]]; then
    echo "Usage: ddex-info <UPC> [detail_limit]"
    echo "  detail_limit: Number of tracks to show in detail (default: 20, use 'all' for all tracks)"
    return 1
  fi

  # Check if xq is available
  if ! command -v xq &> /dev/null; then
    echo "âŒ xq not found. Install with: brew install xq"
    return 1
  fi

  # Handle 'all' keyword
  if [[ "$detail_limit" == "all" ]]; then
    detail_limit=999999
  fi

  # Find all S3 directories for this UPC
  echo "ğŸ” Searching for UPC: $upc\n"
  local all_dirs=$(AWS_PROFILE=production s5cmd ls "s3://stage-ingest-production/supply-chain/incoming/" | grep "${upc}_" | awk '{print $NF}')

  if [[ -z "$all_dirs" ]]; then
    echo "âŒ No release found for UPC: $upc"
    return 1
  fi

  # Count number of versions
  local version_count=$(echo "$all_dirs" | wc -l | tr -d ' ')

  # Select newest version (last one, since sorted by timestamp)
  local s3_dir=$(echo "$all_dirs" | tail -1)

  # Display all versions if multiple exist
  if [[ $version_count -gt 1 ]]; then
    echo "ğŸ“¦ Found $version_count versions:"
    echo "$all_dirs" | while IFS= read -r dir; do
      if [[ "$dir" == "$s3_dir" ]]; then
        echo "   âœ“ $dir (using newest)"
      else
        echo "     $dir"
      fi
    done
    echo ""
  else
    echo "ğŸ“¦ Found release: $s3_dir"
  fi

  # Fetch the XML file
  local xml_file="${upc}.xml"
  local xml_path="s3://stage-ingest-production/supply-chain/incoming/${s3_dir}${xml_file}"

  echo "ğŸ’¡ To inspect full XML: AWS_PROFILE=production s5cmd cat \"$xml_path\"\n"

  local xml_content=$(AWS_PROFILE=production s5cmd cat "$xml_path" 2>/dev/null)

  if [[ -z "$xml_content" ]]; then
    echo "âŒ Could not fetch XML file"
    return 1
  fi

  # Parse album information
  echo "\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo "ğŸ“€ ALBUM INFORMATION"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"

  # Save XML to temp file for xq processing
  local tmp_xml=$(mktemp)
  echo "$xml_content" > "$tmp_xml"

  local release_title=$(xq -x "string(//*[local-name()='ReleaseDetailsByTerritory'][1]/*[local-name()='Title'][1]/*[local-name()='TitleText'])" < "$tmp_xml" 2>/dev/null)
  local release_artist=$(xq -x "string(//*[local-name()='ReleaseDetailsByTerritory'][1]/*[local-name()='DisplayArtistName'])" < "$tmp_xml" 2>/dev/null)
  local label=$(xq -x "string(//*[local-name()='ReleaseDetailsByTerritory'][1]/*[local-name()='LabelName'])" < "$tmp_xml" 2>/dev/null)
  local release_date=$(xq -x "string(//*[local-name()='ReleaseDetailsByTerritory'][1]/*[local-name()='ReleaseDate'])" < "$tmp_xml" 2>/dev/null)

  echo "Title:   $release_title"
  echo "Artist:  $release_artist"
  echo "Label:   $label"
  echo "Date:    $release_date"
  echo "UPC:     $upc"

  # Get track count using xq
  local track_count=$(xq -x "count(//*[local-name()='SoundRecording'])" < "$tmp_xml" 2>/dev/null)
  echo "Tracks:  $track_count"

  # Parse tracks
  echo "\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo "ğŸµ TRACKS & FILES"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"

  # Count codecs efficiently using xq XPath predicates
  echo "âš¡ Analyzing audio formats...\n"

  typeset -A codec_counts

  # Dynamically discover all codec types in the XML
  # Get all AudioCodecType text values (non-UserDefined)
  local regular_codecs=$(xq -x '//*[local-name()="AudioCodecType"][text()!="UserDefined"]/text()' < "$tmp_xml" 2>/dev/null | sort -u)

  # Get all UserDefinedValue attributes (for codecs like Atmos)
  local user_defined_codecs=$(xq -x '//*[local-name()="AudioCodecType"]/@UserDefinedValue' < "$tmp_xml" 2>/dev/null | sort -u)

  # Combine all codecs
  local all_codecs=$(echo -e "$regular_codecs\n$user_defined_codecs" | grep -v '^$' | sort -u)

  # Count tracks for each codec
  while IFS= read -r codec; do
    [[ -z "$codec" ]] && continue

    # Check if it's a UserDefined codec or regular codec
    if echo "$user_defined_codecs" | grep -q "^${codec}$"; then
      # UserDefined codec - search by @UserDefinedValue attribute
      codec_counts[$codec]=$(xq -x '//*[local-name()="SoundRecording"][.//*[local-name()="AudioCodecType"][@UserDefinedValue="'"$codec"'"]]/*[local-name()="ResourceReference"]/text()' < "$tmp_xml" 2>/dev/null | sort -u | wc -l | tr -d ' ')
    else
      # Regular codec - search by text content
      codec_counts[$codec]=$(xq -x '//*[local-name()="SoundRecording"][.//*[local-name()="AudioCodecType"][text()="'"$codec"'"]]/*[local-name()="ResourceReference"]/text()' < "$tmp_xml" 2>/dev/null | sort -u | wc -l | tr -d ' ')
    fi
  done <<< "$all_codecs"

  # Process each track (limited for detailed output)
  local tracks_shown=0
  for i in {1..${track_count}}; do
    # Check if we've hit the display limit
    if [[ $i -gt $detail_limit ]]; then
      echo "... and $((track_count - detail_limit)) more tracks (use 'ddex-info $upc all' to show all)\n"
      break
    fi

    local track_title=$(xq -x "string(//*[local-name()='SoundRecording'][$i]/*[local-name()='DisplayTitleText'])" < "$tmp_xml" 2>/dev/null)
    local track_artist=$(xq -x "string(//*[local-name()='SoundRecording'][$i]/*[local-name()='DisplayArtistName'])" < "$tmp_xml" 2>/dev/null)
    local isrc=$(xq -x "string(//*[local-name()='SoundRecording'][$i]//*[local-name()='ISRC'])" < "$tmp_xml" 2>/dev/null)
    local duration=$(xq -x "string(//*[local-name()='SoundRecording'][$i]/*[local-name()='Duration'])" < "$tmp_xml" 2>/dev/null)

    echo "[$i] $track_title"
    echo "    Artist: $track_artist"
    echo "    ISRC:   $isrc"
    echo "    Duration: $duration"
    echo "    Files:"

    ((tracks_shown++))

    # Process all SoundRecordingEdition elements (there can be multiple)
    local edition_count=$(xq -x "count(//*[local-name()='SoundRecording'][$i]/*[local-name()='SoundRecordingEdition'])" < "$tmp_xml" 2>/dev/null)

    for edition in {1..${edition_count}}; do
      # Get the number of technical details in this edition
      local file_count=$(xq -x "count(//*[local-name()='SoundRecording'][$i]/*[local-name()='SoundRecordingEdition'][$edition]/*[local-name()='TechnicalDetails'])" < "$tmp_xml" 2>/dev/null)

      # Skip if no technical details (avoid {1..0} iteration bug)
      if [[ $file_count -lt 1 ]]; then
        continue
      fi

      for j in {1..${file_count}}; do
        local codec=$(xq -x "string(//*[local-name()='SoundRecording'][$i]/*[local-name()='SoundRecordingEdition'][$edition]/*[local-name()='TechnicalDetails'][$j]/*[local-name()='DeliveryFile']/*[local-name()='AudioCodecType'])" < "$tmp_xml" 2>/dev/null)
        local codec_user_defined=$(xq -x "string(//*[local-name()='SoundRecording'][$i]/*[local-name()='SoundRecordingEdition'][$edition]/*[local-name()='TechnicalDetails'][$j]/*[local-name()='DeliveryFile']/*[local-name()='AudioCodecType']/@UserDefinedValue)" < "$tmp_xml" 2>/dev/null)
        local sample_rate=$(xq -x "string(//*[local-name()='SoundRecording'][$i]/*[local-name()='SoundRecordingEdition'][$edition]/*[local-name()='TechnicalDetails'][$j]/*[local-name()='DeliveryFile']/*[local-name()='SamplingRate'])" < "$tmp_xml" 2>/dev/null)
        local bit_depth=$(xq -x "string(//*[local-name()='SoundRecording'][$i]/*[local-name()='SoundRecordingEdition'][$edition]/*[local-name()='TechnicalDetails'][$j]/*[local-name()='DeliveryFile']/*[local-name()='BitsPerSample'])" < "$tmp_xml" 2>/dev/null)
        local bit_rate=$(xq -x "string(//*[local-name()='SoundRecording'][$i]/*[local-name()='SoundRecordingEdition'][$edition]/*[local-name()='TechnicalDetails'][$j]/*[local-name()='DeliveryFile']/*[local-name()='BitRate'])" < "$tmp_xml" 2>/dev/null)
        local channels=$(xq -x "string(//*[local-name()='SoundRecording'][$i]/*[local-name()='SoundRecordingEdition'][$edition]/*[local-name()='TechnicalDetails'][$j]/*[local-name()='DeliveryFile']/*[local-name()='NumberOfChannels'])" < "$tmp_xml" 2>/dev/null)
        local file_uri=$(xq -x "string(//*[local-name()='SoundRecording'][$i]/*[local-name()='SoundRecordingEdition'][$edition]/*[local-name()='TechnicalDetails'][$j]/*[local-name()='DeliveryFile']/*[local-name()='File']/*[local-name()='URI'])" < "$tmp_xml" 2>/dev/null)

        # Fallback to TechnicalResourceDetailsReference if no URI
        if [[ -z "$file_uri" ]]; then
          file_uri=$(xq -x "string(//*[local-name()='SoundRecording'][$i]/*[local-name()='SoundRecordingEdition'][$edition]/*[local-name()='TechnicalDetails'][$j]/*[local-name()='TechnicalResourceDetailsReference'])" < "$tmp_xml" 2>/dev/null)
        fi

        # Use UserDefinedValue if codec is "UserDefined"
        if [[ "$codec" == "UserDefined" && -n "$codec_user_defined" ]]; then
          codec="$codec_user_defined"
        fi

        # Format quality string
        local quality=""
        if [[ -n "$bit_depth" ]]; then
          quality="${sample_rate}kHz/${bit_depth}bit"
        elif [[ -n "$bit_rate" ]]; then
          quality="${sample_rate}kHz/${bit_rate}kbps"
        else
          quality="${sample_rate}kHz"
        fi

        # Add channel info for multi-channel audio
        if [[ -n "$channels" && "$channels" != "2" ]]; then
          quality="${quality}/${channels}ch"
        fi

        echo "      â€¢ $codec ($quality) - $file_uri"
      done
    done

    echo ""
  done

  # Display summary statistics
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
  echo "ğŸ“Š QUALITY SUMMARY"
  echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"

  # Display all found codecs
  while IFS= read -r codec; do
    [[ -z "$codec" ]] && continue

    local count=${codec_counts[$codec]:-0}
    [[ -z "$count" ]] && count=0

    # Skip if count is 0 and codec is not Atmos
    if [[ $count -eq 0 && "$codec" != "E-AC-3_JOC" ]]; then
      continue
    fi

    local percentage=$(( count * 100 / track_count ))

    # Highlight Atmos specially
    if [[ "$codec" == "E-AC-3_JOC" ]]; then
      if [[ $count -eq 0 ]]; then
        echo "ğŸ§ Dolby Atmos (E-AC-3_JOC): Not available"
      else
        echo "ğŸ§ Dolby Atmos (E-AC-3_JOC): $count/$track_count tracks ($percentage%)"
      fi
    else
      echo "   $codec: $count/$track_count tracks ($percentage%)"
    fi
  done <<< "$all_codecs"

  # Cleanup temp files
  rm -f "$tmp_xml" 2>/dev/null

  echo "\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
}
