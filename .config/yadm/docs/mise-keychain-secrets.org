#+TITLE: Managing Secrets with mise + macOS Keychain
#+AUTHOR: jfd
#+DATE: 2026-02-12

* Overview

Instead of storing API keys as plaintext in =~/.mise.toml=, secrets are stored
in the macOS Keychain and retrieved at runtime using mise's template syntax.

The Keychain encrypts secrets at rest, protected by your login password.

* How It Works

=~/.mise.toml= uses mise's Tera template engine to call =security= (the
Keychain CLI) at runtime:

#+begin_src toml
[env]
OPENAI_API_KEY = "{{exec(command='security find-generic-password -a ' ~ env.USER ~ ' -s openai-api-key -w')}}"
#+end_src

When mise evaluates the config, it executes the =security= command, which
returns the secret from Keychain. The plaintext value never touches the
filesystem.

* Adding a New Secret

1. Store the secret in Keychain:

#+begin_src bash
security add-generic-password -a "$USER" -s "my-service-api-key" -w "the-actual-secret-value" -U
#+end_src

   - =-a "$USER"= — account name (your macOS username)
   - =-s "my-service-api-key"= — service name (used as the lookup key)
   - =-w "..."= — the secret value
   - =-U= — update if it already exists

2. Add the template to =~/.mise.toml=:

#+begin_src toml
[env]
MY_SERVICE_API_KEY = "{{exec(command='security find-generic-password -a ' ~ env.USER ~ ' -s my-service-api-key -w')}}"
#+end_src

3. Verify:

#+begin_src bash
mise env | grep MY_SERVICE
#+end_src

* Managing Existing Secrets

** View a secret

#+begin_src bash
security find-generic-password -a "$USER" -s "openai-api-key" -w
#+end_src

** Update a secret

#+begin_src bash
security add-generic-password -a "$USER" -s "openai-api-key" -w "new-secret-value" -U
#+end_src

** Delete a secret

#+begin_src bash
security delete-generic-password -a "$USER" -s "openai-api-key"
#+end_src

** List all stored secrets

#+begin_src bash
security dump-keychain | grep -A4 "svce.*api-key\|svce.*api-token"
#+end_src

* Current Secrets

| Environment Variable | Keychain Service Name |
|----------------------+-----------------------|
| OPENAI_API_KEY       | openai-api-key        |
| GEMINI_API_KEY       | gemini-api-key        |
| OPENROUTER_API_KEY   | openrouter-api-key    |
| JIRA_API_TOKEN       | jira-api-token        |
| ANTHROPIC_API_KEY    | anthropic-api-key     |
| BRAVE_API_KEY        | brave-api-key         |

* Restoring Secrets on a New Machine

Keychain items do *not* transfer automatically. On a new machine, re-add each
secret manually:

#+begin_src bash
security add-generic-password -a "$USER" -s "openai-api-key" -w "sk-..." -U
security add-generic-password -a "$USER" -s "gemini-api-key" -w "AIza..." -U
security add-generic-password -a "$USER" -s "openrouter-api-key" -w "sk-or-..." -U
security add-generic-password -a "$USER" -s "jira-api-token" -w "ATATT..." -U
security add-generic-password -a "$USER" -s "anthropic-api-key" -w "sk-ant-..." -U
security add-generic-password -a "$USER" -s "brave-api-key" -w "BSAH..." -U
#+end_src

Until the secrets are added, =mise= will fail to resolve the affected
environment variables.

* Why Keychain Over Alternatives

| Approach           | Pros                          | Cons                              |
|--------------------+-------------------------------+-----------------------------------|
| Plaintext in file  | Simple                        | Secrets readable by any process   |
| macOS Keychain     | Encrypted, no extra tools     | macOS only, manual restore        |
| 1Password CLI (op) | Cross-platform, team sharing  | Requires 1Password subscription   |
| sops + age         | Cross-platform, git-friendly  | Extra tooling, key management     |
