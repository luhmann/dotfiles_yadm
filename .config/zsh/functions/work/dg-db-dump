#!/usr/bin/env zsh
# @name: dg-db-dump
# @description: Dump sanitized database (excluding sensitive tables)
# @category: work
# @keywords: dg, database, dump, backup, postgres, pg_dump, sanitized
# @usage: dg-db-dump [args]
# @example: dg-db-dump

dg-db-dump () {
  local stage="${1:-umg79}"
  local profile="${2:-production}"

  # directories
  local tunnel_dir="$HOME/Dev/dg/dg-stage-deploy/.rds-tunnel"
  local kube="$HOME/Dev/dg/dg-stage-deploy/.eks-tunnel/kubeconfig-${stage}.yml"

  (
    # remember where the user is, then cd into the tunnel dir
    local caller_cwd="$PWD"
    cd "$tunnel_dir" || { echo "‚ùå  Cannot cd into $tunnel_dir" >&2; exit 1; }

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ K8s config ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    export KUBECONFIG="$kube"

    # Get namespace, port, database, and user for this stage
    local namespace port db_name db_user
    if [[ "$stage" == "umg79" ]]; then
      namespace="dg-stage-prod"
      port=5433
      db_name="dgstage"
      db_user="dg_stage_read_only"
    elif [[ "$stage" == "umg79hybrid" ]]; then
      namespace="argo-workflows-prod"
      port=5435
      db_name="dgstage"
      db_user="argo"
    else
      namespace="dg-stage-staging"
      port=5434
      db_name="dgstageimport"
      db_user="dg_stage_read_only"
    fi

    # Variables for cleanup
    local pf_pid=""
    local pgpass_file=""
    local tunnel_started=false

    # Enhanced cleanup handler for Ctrl+C and exit
    cleanup() {
      echo "üßπ Cleaning up..."

      # Remove .pgpass file
      if [[ -n "$pgpass_file" && -f "$pgpass_file" ]]; then
        rm -f "$pgpass_file" 2>/dev/null
        echo "   ‚úì Removed .pgpass file"
      fi

      # Kill port-forward process with retry
      if [[ -n "$pf_pid" ]]; then
        echo "   üîå Stopping port-forward (PID: $pf_pid)..."
        kill "$pf_pid" 2>/dev/null || true
        sleep 2

        # Force kill if still running
        if kill -0 "$pf_pid" 2>/dev/null; then
          echo "   üî® Force killing port-forward..."
          kill -9 "$pf_pid" 2>/dev/null || true
        fi
      fi

      # Force kill any remaining port-forwards on this port
      if pgrep -f "kubectl port-forward.*${port}:5432" >/dev/null 2>&1; then
        echo "   üî® Force killing remaining port-forwards..."
        pkill -9 -f "kubectl port-forward.*${port}:5432" 2>/dev/null || true
      fi

      # Stop the tunnel pod if we started it
      if [[ "$tunnel_started" == "true" ]]; then
        echo "   üöá Stopping tunnel pod..."
        if STAGE="$stage" AWS_PROFILE="$profile" make stop-db-tunnel 2>/dev/null; then
          echo "   ‚úì Tunnel pod stopped"
        else
          echo "   ‚ö†Ô∏è  Warning: Failed to stop tunnel pod rds-tunnel-$USER"
        fi
      fi

      # Wait for port to be freed
      echo "   ‚è≥ Waiting for port to be freed..."
      sleep 3
      echo "‚úÖ Cleanup complete"
    }
    trap cleanup EXIT INT TERM

    # 1. Start the DB tunnel pod with error handling
    echo "üöá Starting DB tunnel pod..."
    if ! STAGE="$stage" AWS_PROFILE="$profile" make start-db-tunnel; then
      echo "‚ùå Failed to start DB tunnel pod"
      exit 1
    fi
    tunnel_started=true
    echo "‚úì Tunnel pod started"

    # Wait for tunnel pod to be ready
    echo "‚è≥ Waiting for tunnel pod to be ready..."
    if ! kubectl wait --namespace "$namespace" --for=condition=Ready pod/rds-tunnel-"$USER" --timeout=60s; then
      echo "‚ùå Tunnel pod failed to become ready within 60 seconds"
      exit 1
    fi
    echo "‚úì Tunnel pod is ready"

    # 2. Start port-forward in the background
    echo "üîå Starting port-forward to localhost:$port..."
    STAGE="$stage" AWS_PROFILE="$profile" make port-forward-db-tunnel &
    pf_pid=$!

    # Wait for port-forward to be established with timeout
    echo "‚è≥ Waiting for port-forward to establish..."
    local timeout=60
    local wait_interval=2
    while [[ $timeout -gt 0 ]]; do
      # Check if port is available using netcat
      if command -v nc >/dev/null 2>&1 && nc -z 127.0.0.1 "$port" 2>/dev/null; then
        echo "‚úì Port-forward established on localhost:$port"
        break
      fi

      # Alternative check using /dev/tcp if nc is not available
      if (exec 3<>/dev/tcp/127.0.0.1/"$port") 2>/dev/null; then
        exec 3>&-
        echo "‚úì Port-forward established on localhost:$port"
        break
      fi

      # Check if port-forward process is still running
      if ! kill -0 "$pf_pid" 2>/dev/null; then
        echo "‚ùå Port-forward process died unexpectedly"
        exit 1
      fi

      echo "   Still waiting... (${timeout}s remaining)"
      sleep $wait_interval
      ((timeout-=wait_interval))
    done

    if [[ $timeout -le 0 ]]; then
      echo "‚ùå Port-forward failed to establish within 60 seconds"
      exit 1
    fi

    # 3. Get database password
    echo "üîë Retrieving database password..."
    local password
    if ! password="$(STAGE="$stage" AWS_PROFILE="$profile" make --silent snatch-db-url 2>/dev/null)"; then
      echo "‚ùå Failed to retrieve database password"
      exit 1
    fi

    if [[ -z "$password" ]]; then
      echo "‚ùå Database password is empty"
      exit 1
    fi

    echo "‚úì Password retrieved (${#password} characters)"

    # 4. Create a temporary .pgpass file for non-interactive auth
    pgpass_file="$(mktemp)"
    if [[ $? -ne 0 || -z "$pgpass_file" ]]; then
      echo "‚ùå Failed to create temporary .pgpass file"
      exit 1
    fi

    # Format: hostname:port:database:username:password
    echo "127.0.0.1:${port}:${db_name}:${db_user}:${password}" > "$pgpass_file"
    chmod 600 "$pgpass_file"

    # Log connection info (without password)
    echo "üîó Database connection details:"
    echo "   Connect to: 127.0.0.1:${port}"
    echo "   Database: ${db_name}"
    echo "   User: ${db_user}"
    echo "   Password: [${#password} characters]"
    echo "   .pgpass file: ${pgpass_file}"

    # Test database connection before proceeding
    echo "üß™ Testing database connection..."
    if ! PGPASSFILE="$pgpass_file" pg_isready -h 127.0.0.1 -p "$port" -U "$db_user" -d "$db_name" -q; then
      echo "‚ùå Database connection test failed"
      exit 1
    fi
    echo "‚úì Database connection successful"

    # 7. Run sanitized dump inline (PGPASSFILE makes pg_dump skip the prompt)
    local output_file="${namespace}-$(date '+%Y-%m-%d').sql"
    echo "üì¶ Starting database dump to: $output_file"
    echo "   This may take several minutes..."

    if ! PGPASSFILE="$pgpass_file" pg_dump -h 127.0.0.1 -p "$port" -U "$db_user" -d "$db_name" \
        --exclude-table-data=users \
        --exclude-table-data=device_identifiers \
        --exclude-table-data=devices \
        --exclude-table-data=favorites \
        --exclude-table-data=live_concert_reminders \
        --exclude-table-data=playback_progress \
        --exclude-table-data=postal_addresses \
        --exclude-table-data=tickets \
        --exclude-table-data=user_codes \
        --exclude-table-data=user_push_endpoints \
        --exclude-table-data=voucher_redemptions \
        --exclude-table-data=vouchers \
        --exclude-table-data=payments \
        --exclude-table-data=playbacks \
        --no-owner \
        --no-privileges \
        --clean \
        --if-exists > "$caller_cwd/$output_file"; then
      echo "‚ùå Database dump failed"
      exit 1
    fi

    echo "‚úÖ Database dump completed successfully!"
    echo "   Output file: $caller_cwd/$output_file"
    echo "   File size: $(du -h "$caller_cwd/$output_file" | cut -f1)"

    # Cleanup will be called automatically by trap
  )
}
