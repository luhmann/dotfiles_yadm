#!/usr/bin/env zsh
# @name: dg-db-query-csv
# @description: Execute SQL query and export results to CSV
# @category: work
# @keywords: database, query, csv, postgres, psql, export
# @usage: dg-db-query-csv [args]
# @example: dg-db-query-csv

dg-db-query-csv () {
  local query="$1"
  local stage="${2:-umg79}"
  local profile="${3:-production}"

  # Check if query is provided
  if [[ -z "$query" ]]; then
    echo "‚ùå SQL query is required as the first parameter"
    echo "Usage: dg_db_query_csv 'SELECT * FROM table_name LIMIT 10' [stage] [profile]"
    return 1
  fi

  # Display the query and ask for confirmation
  echo "üîç SQL Query to execute:"
  echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
  echo "$query"
  echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
  echo ""
  echo "üéØ Target: Stage '$stage', Profile '$profile'"
  echo ""
  echo -n "‚ùì Do you want to execute this query? (y/N): "
  read -r REPLY
  echo
  if [[ ! $REPLY =~ ^[Yy]$ ]]; then
    echo "‚ùå Query execution cancelled"
    return 1
  fi

  # directories
  local tunnel_dir="$HOME/Dev/dg/dg-stage-deploy/.rds-tunnel"
  local kube="$HOME/Dev/dg/dg-stage-deploy/.eks-tunnel/kubeconfig-${stage}.yml"

  (
    # remember where the user is, then cd into the tunnel dir
    local caller_cwd="$PWD"
    cd "$tunnel_dir" || { echo "‚ùå  Cannot cd into $tunnel_dir" >&2; exit 1; }

    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ K8s config ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    export KUBECONFIG="$kube"

    # Get namespace, port, database, and user for this stage
    local namespace port db_name db_user
    if [[ "$stage" == "umg79" ]]; then
      namespace="dg-stage-prod"
      port=5433
      db_name="dgstage"
      db_user="dg_stage_read_only"
    elif [[ "$stage" == "umg79hybrid" ]]; then
      namespace="argo-workflows-prod"
      port=5435
      db_name="dgstage"
      db_user="argo"
    else
      namespace="dg-stage-staging"
      port=5434
      db_name="dgstageimport"
      db_user="dg_stage_read_only"
    fi

    # Variables for cleanup
    local pf_pid=""
    local pgpass_file=""
    local tunnel_started=false

    # Enhanced cleanup handler for Ctrl+C and exit
    cleanup() {
      echo "üßπ Cleaning up..."

      # Remove .pgpass file
      if [[ -n "$pgpass_file" && -f "$pgpass_file" ]]; then
        rm -f "$pgpass_file" 2>/dev/null
        echo "   ‚úì Removed .pgpass file"
      fi

      # Kill port-forward process with retry
      if [[ -n "$pf_pid" ]]; then
        echo "   üîå Stopping port-forward (PID: $pf_pid)..."
        kill "$pf_pid" 2>/dev/null || true
        sleep 2

        # Force kill if still running
        if kill -0 "$pf_pid" 2>/dev/null; then
          echo "   üî® Force killing port-forward..."
          kill -9 "$pf_pid" 2>/dev/null || true
        fi
      fi

      # Force kill any remaining port-forwards on this port
      if pgrep -f "kubectl port-forward.*${port}:5432" >/dev/null 2>&1; then
        echo "   üî® Force killing remaining port-forwards..."
        pkill -9 -f "kubectl port-forward.*${port}:5432" 2>/dev/null || true
      fi

      # Stop the tunnel pod if we started it
      if [[ "$tunnel_started" == "true" ]]; then
        echo "   üöá Stopping tunnel pod..."
        if STAGE="$stage" AWS_PROFILE="$profile" make stop-db-tunnel 2>/dev/null; then
          echo "   ‚úì Tunnel pod stopped"
        else
          echo "   ‚ö†Ô∏è  Warning: Failed to stop tunnel pod rds-tunnel-$USER"
        fi
      fi

      # Wait for port to be freed
      echo "   ‚è≥ Waiting for port to be freed..."
      sleep 3
      echo "‚úÖ Cleanup complete"
    }
    trap cleanup EXIT INT TERM

    # 1. Start the DB tunnel pod with error handling
    echo "üöá Starting DB tunnel pod..."
    if ! STAGE="$stage" AWS_PROFILE="$profile" make start-db-tunnel; then
      echo "‚ùå Failed to start DB tunnel pod"
      exit 1
    fi
    tunnel_started=true
    echo "‚úì Tunnel pod started"

    # Wait for tunnel pod to be ready
    echo "‚è≥ Waiting for tunnel pod to be ready..."
    if ! kubectl wait --namespace "$namespace" --for=condition=Ready pod/rds-tunnel-"$USER" --timeout=60s; then
      echo "‚ùå Tunnel pod failed to become ready within 60 seconds"
      exit 1
    fi
    echo "‚úì Tunnel pod is ready"

    # 2. Start port-forward in the background
    echo "üîå Starting port-forward to localhost:$port..."
    STAGE="$stage" AWS_PROFILE="$profile" make port-forward-db-tunnel &
    pf_pid=$!

    # Wait for port-forward to be established with timeout
    echo "‚è≥ Waiting for port-forward to establish..."
    local timeout=60
    local wait_interval=2
    while [[ $timeout -gt 0 ]]; do
      # Check if port is available using netcat
      if command -v nc >/dev/null 2>&1 && nc -z 127.0.0.1 "$port" 2>/dev/null; then
        echo "‚úì Port-forward established on localhost:$port"
        break
      fi

      # Alternative check using /dev/tcp if nc is not available
      if (exec 3<>/dev/tcp/127.0.0.1/"$port") 2>/dev/null; then
        exec 3>&-
        echo "‚úì Port-forward established on localhost:$port"
        break
      fi

      # Check if port-forward process is still running
      if ! kill -0 "$pf_pid" 2>/dev/null; then
        echo "‚ùå Port-forward process died unexpectedly"
        exit 1
      fi

      echo "   Still waiting... (${timeout}s remaining)"
      sleep $wait_interval
      ((timeout-=wait_interval))
    done

    if [[ $timeout -le 0 ]]; then
      echo "‚ùå Port-forward failed to establish within 60 seconds"
      exit 1
    fi

    # 3. Get the full ecto URL (ecto://user:pass@host:port/db)
    echo "üîë Retrieving database credentials..."
    local url
    if ! url="$(STAGE="$stage" AWS_PROFILE="$profile" make --silent snatch-db-url)"; then
      echo "‚ùå Failed to retrieve database URL"
      exit 1
    fi

    if [[ -z "$url" ]]; then
      echo "‚ùå Database URL is empty"
      exit 1
    fi

    # 4. Pull the individual parts out of the URL
    #    scheme://user:pass@host:port/dbname
    local no_scheme="${url#*://}"          # user:pass@host:port/db
    local creds="${no_scheme%%@*}"         # user:pass
    local rest="${no_scheme#*@}"           # host:port/db

    local user="${creds%%:*}"              # user
    local pass="${creds#*:}"               # pass

    local hostport="${rest%%/*}"           # host:port/db
    local host="${hostport%%:*}"           # host

    local db="${rest#*/}"                  # dbname (may contain %... ‚Üí leave as-is)

    # Validate extracted credentials
    if [[ -z "$user" || -z "$pass" || -z "$db" ]]; then
      echo "‚ùå Failed to parse database credentials from URL"
      echo "   User: '$user', Pass: [${#pass} chars], DB: '$db'"
      exit 1
    fi

    # 5. Create a temporary .pgpass file for non-interactive auth
    pgpass_file="$(mktemp)"
    if [[ $? -ne 0 || -z "$pgpass_file" ]]; then
      echo "‚ùå Failed to create temporary .pgpass file"
      exit 1
    fi

    # Use 127.0.0.1 in .pgpass since psql connects to localhost
    echo "127.0.0.1:${port}:${db}:${user}:${pass}" > "$pgpass_file"
    chmod 600 "$pgpass_file"

    # Log connection info (without password)
    echo "üîó Database connection details:"
    echo "   Connect to: 127.0.0.1:${port}"
    echo "   Database: ${db}"
    echo "   User: ${user}"
    echo "   Password: [${#pass} characters]"
    echo "   .pgpass file: ${pgpass_file}"

    # Test database connection before proceeding
    echo "üß™ Testing database connection..."
    if ! PGPASSFILE="$pgpass_file" pg_isready -h 127.0.0.1 -p "$port" -U "$user" -d "$db" -q; then
      echo "‚ùå Database connection test failed"
      exit 1
    fi
    echo "‚úì Database connection successful"

    # 6. Execute the query and export to CSV
    local timestamp=$(date '+%Y-%m-%d-%H%M%S')
    local output_file="query-output-${timestamp}.csv"
    echo "üìä Executing query and exporting to CSV: $output_file"
    echo "   This may take several minutes depending on the query..."

    # Use psql with \copy command to export CSV with headers
    if ! PGPASSFILE="$pgpass_file" psql -h 127.0.0.1 -p "$port" -U "$user" -d "$db" \
        -c "\\copy ($query) TO STDOUT WITH CSV HEADER" > "$caller_cwd/$output_file"; then
      echo "‚ùå Query execution failed"
      exit 1
    fi

    echo "‚úÖ Query executed successfully!"
    echo "   Output file: $caller_cwd/$output_file"
    echo "   File size: $(du -h "$caller_cwd/$output_file" | cut -f1)"
    echo "   Rows exported: $(($(wc -l < "$caller_cwd/$output_file") - 1))"

    # Cleanup will be called automatically by trap
  )
}
